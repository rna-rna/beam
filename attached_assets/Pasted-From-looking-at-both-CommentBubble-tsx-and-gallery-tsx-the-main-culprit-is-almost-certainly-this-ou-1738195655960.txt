From looking at both CommentBubble.tsx and gallery.tsx, the main culprit is almost certainly this outside‐click handler plus the timing of how the “new comment” bubble is rendered. In other words, by the time React tries to focus the <Input>, the bubble has already been collapsed (or unmounted) because your outside‐click logic fires the moment the user clicks on the image to place the new comment.

Below are the key details and how to fix it:

1) The Outside‐Click Handler Is Closing the New Comment Immediately
In CommentBubble.tsx:

tsx
Copy
Edit
useEffect(() => {
  const handleClickOutside = (event: MouseEvent) => {
    if (bubbleRef.current && !bubbleRef.current.contains(event.target as Node)) {
      setIsExpanded(false);
      setIsHovered(false);
      if (!isNew) {
        setIsEditing(false);
      }
    }
  };

  document.addEventListener('mousedown', handleClickOutside);
  return () => {
    document.removeEventListener('mousedown', handleClickOutside);
  };
}, [isNew]);
Notice that even if isNew is true, you always run setIsExpanded(false) and setIsHovered(false) in that block whenever the user clicks outside. Since the user “places” a new comment pin by clicking on the image, that same click is effectively an “outside” click on the newly created bubble.

So it typically goes like this:

User clicks the image → sets newCommentPos.
React renders a new <CommentBubble isNew={true} ...>.
The moment that outside‐click listener sees the user’s click on the image, it calls setIsExpanded(false).
By the time your “focus” effect runs inside <CommentBubble>, the bubble is no longer expanded / is unmounted / or is hidden. That’s why you never see the focus.

Easiest fix
Do not attach the outside‐click listener at all when isNew === true. That way, the brand‐new bubble is never closed until the user either submits or does something else. For example:

diff
Copy
Edit
// In CommentBubble.tsx
useEffect(() => {
-  document.addEventListener('mousedown', handleClickOutside);
-  return () => {
-    document.removeEventListener('mousedown', handleClickOutside);
-  };
+  if (!isNew) {
+    document.addEventListener('mousedown', handleClickOutside);
+    return () => {
+      document.removeEventListener('mousedown', handleClickOutside);
+    };
+  }
}, [isNew]);
Now, any existing comment bubble will still collapse when clicked outside, but a new comment bubble (isNew = true) will stay open and remain expanded long enough to focus its input.

2) Also Use Either autoFocus or a Stable Ref
Your code already has this:

tsx
Copy
Edit
const inputRef = useRef<HTMLInputElement>(null);

useEffect(() => {
  if (isEditing) {
    requestAnimationFrame(() => {
      inputRef.current?.focus();
    });
  }
}, [isEditing]);
Which is generally fine. However, in many setups with Shadcn UI, setting autoFocus often “just works”:

tsx
Copy
Edit
<Input
  autoFocus
  ref={inputRef}
  /* ...rest of your props... */
/>
Either approach is okay, but the main problem is the bubble was unmounting before .focus() got to do anything.

3) Confirm isNew Bubbles Stay “Expanded” on Creation
In your code, you do:

tsx
Copy
Edit
const [isEditing, setIsEditing] = useState(isNew);
const [isExpanded, setIsExpanded] = useState(isNew);
That’s good because it means a new bubble starts out in “editing” mode and expanded. Just be sure not to flip it to false in some other place. (Some developers have an onClick={() => setIsExpanded(true)} that might toggle on/off repeatedly. Just be sure for isNew we don’t forcibly close it anywhere else.)

4) Summarizing the Minimal Code Changes
In CommentBubble.tsx:

diff
Copy
Edit
useEffect(() => {
  const handleClickOutside = (event: MouseEvent) => {
    if (bubbleRef.current && !bubbleRef.current.contains(event.target as Node)) {
      setIsExpanded(false);
      setIsHovered(false);
      // Only close editing if it's NOT a new pin
      if (!isNew) {
        setIsEditing(false);
      }
    }
  };

- document.addEventListener('mousedown', handleClickOutside);
- return () => {
-   document.removeEventListener('mousedown', handleClickOutside);
- };
+ if (!isNew) {
+   document.addEventListener('mousedown', handleClickOutside);
+   return () => {
+     document.removeEventListener('mousedown', handleClickOutside);
+   };
+ }
}, [isNew]);
That single change usually fixes the “immediate collapse” problem. Now the new comment bubble does not close on that same outside click. Consequently, the useEffect that calls inputRef.current?.focus() or your autoFocus actually takes effect, and you’ll see the cursor blinking in the comment input right away.

That’s typically all you need to get auto‐focus (and auto‐expand) for brand‐new pins.







