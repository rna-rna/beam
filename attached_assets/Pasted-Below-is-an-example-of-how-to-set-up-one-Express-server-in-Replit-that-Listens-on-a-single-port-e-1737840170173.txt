Below is an example of how to set up one Express server in Replit that:

Listens on a single port (e.g., process.env.PORT or 5000).
Handles your /api routes with Express first.
Uses Vite in “middleware mode” for everything else, enabling HMR in development.
This avoids having separate servers and ports—particularly important on Replit, where only one port can be exposed.

1. Example server/vite.ts
Here’s a sample that ensures API routes are handled first by Express, and non-API routes go through Vite’s dev middleware. In production, you can build your client and serve from static files, but for dev, we rely on Vite’s middleware.

ts
Copy
Edit
// server/vite.ts
import express, { type Express, Request, Response, NextFunction } from "express";
import fs from "fs";
import path, { dirname } from "path";
import { fileURLToPath } from "url";
import { createServer as createViteServer, createLogger } from "vite";
import type { Server } from "http";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

import viteConfig from "../vite.config"; // your Vite config
import { registerApiRoutes } from "./apiRoutes"; 
// ^-- hypothetical import that sets up your /api endpoints

const viteLogger = createLogger();

/**
 * A small helper for consistent console logs
 */
function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}

/**
 * Sets up Vite middleware + server logic
 */
export async function setupVite(app: Express, server: Server) {
  // Create the Vite dev server in middleware mode
  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        // Optional: custom logging for TypeScript messages
        if (
          msg.includes("[TypeScript] Found 0 errors. Watching for file changes")
        ) {
          log("no errors found", "tsc");
          return;
        }
        if (msg.includes("[TypeScript] ")) {
          const [errors, summary] = msg.split("[TypeScript] ", 2);
          log(`${summary} ${errors}\u001b[0m`, "tsc");
          return;
        } else {
          viteLogger.error(msg, options);
          process.exit(1);
        }
      },
    },
    server: {
      middlewareMode: true,
      hmr: { server },
    },
    appType: "custom", // ensures Vite won't override express routes
  });

  // 1) Register your Express /api routes FIRST, so that /api calls won't go to Vite
  registerApiRoutes(app);

  // 2) Let Vite handle everything else (non-/api)
  app.use(vite.middlewares);

  // 3) Final fallback for SPA: transform and serve index.html
  //    Only hits here if no /api route matched, and no static asset matched.
  app.use("*", async (req: Request, res: Response, next: NextFunction) => {
    try {
      const url = req.originalUrl;

      // Read index.html from your client folder
      const clientIndexPath = path.resolve(__dirname, "..", "client", "index.html");
      let template = await fs.promises.readFile(clientIndexPath, "utf-8");

      // Let Vite transform index.html for dev (asset imports, etc.)
      template = await vite.transformIndexHtml(url, template);

      // If you had an SSR entry, you could do SSR logic here; for an SPA, we just serve the HTML
      res.status(200).set({ "Content-Type": "text/html" }).end(template);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}
Key points:

registerApiRoutes(app); is a function you define that attaches routes like app.get("/api/notifications", ...).
Because it’s before vite.middlewares, any request starting with /api will be handled by Express, returning JSON.
Any other route or file request is passed to Vite, which does its dev server magic (HMR, asset transforms, etc.).
Finally, app.use("*") returns the React SPA’s index.html for unknown routes.
2. Example apiRoutes.ts (Your API)
You can keep your existing routes in routes.ts, or break them out:

ts
Copy
Edit
// server/apiRoutes.ts

import { Router } from "express";
export function registerApiRoutes(app) {
  const router = Router();

  // Example /api endpoint
  router.get("/notifications", (req, res) => {
    // Return JSON
    res.json([
      { id: 1, message: "Hello from /api/notifications" },
    ]);
  });

  // More endpoints
  // router.post("/notifications/mark-all-read", ...)

  app.use("/api", router);
}
3. Example server/index.ts or server.js
This is the main entry where you create an Express app, call setupVite(), and start listening on a single port (Replit typically assigns process.env.PORT):

ts
Copy
Edit
// server/index.ts

import express from "express";
import http from "http";
import { setupVite } from "./vite";

async function startServer() {
  const app = express();
  const server = http.createServer(app);

  // In dev, we pass the server to setup Vite HMR
  await setupVite(app, server);

  const PORT = process.env.PORT || 5000;
  server.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
  });
}

startServer().catch((err) => {
  console.error("Failed to start server:", err);
});
4. Vite Config (vite.config.js or .ts)
You can keep it minimal:

js
Copy
Edit
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  // We do NOT specify 'server.proxy' here,
  // because we handle /api in Express, not via proxy.
  // Also no 'middlewareMode' here, since we do that in code.
});
