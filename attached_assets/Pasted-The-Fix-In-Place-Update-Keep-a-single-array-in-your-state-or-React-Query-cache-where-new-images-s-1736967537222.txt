The Fix: In-Place Update
Keep a single array in your state (or React Query cache) where new images start off with a temporary client ID. Once the server responds with the real ID (e.g. id: 123), merge that object in-place without unmounting. Essentially:

You do not remove the pending item from pendingUploads.
You do not add a brand-new entry from the server to gallery.images.
You do unify them into a single item and do an in-place update of the existing fields.
For example:

ts
Copy code
// Instead of two arrays, maintain a single "images" array in local state (or a single React Query record):
const [images, setImages] = useState<ImageOrPending[]>([]);

// When the gallery first loads from the server:
useEffect(() => {
  if (gallery?.images) {
    setImages((prev) => {
      // Merge any existing pending items with newly loaded server images
      // or just override if you prefer a simpler approach:
      return [...prev, ...gallery.images];
    });
  }
}, [gallery?.images]);

// Whenever a new file is dropped:
function onDrop(acceptedFiles: File[]) {
  acceptedFiles.forEach((file) => {
    const tmpId = nanoid(); // Some stable temporary ID
    const localUrl = URL.createObjectURL(file);
    
    // Create a new "pending" item
    const newItem: ImageOrPending = {
      id: tmpId,                     // <== This is the stable key
      localUrl,
      status: "uploading",
      progress: 0,
      // Optionally track width/height if you know them
      width: 800,
      height: 600,
      // etc.
    };

    // Add it directly into `images`:
    setImages((prev) => [...prev, newItem]);
    
    // Then do the upload
    uploadSingleFile(file, tmpId);
  });
}
Then in your upload function:

ts
Copy code
async function uploadSingleFile(file: File, tmpId: string) {
  try {
    // 1. Ask server for a signed URL
    // 2. Upload to S3 or Cloudflare R2
    // 3. Tell your backend to finalize the upload, returning a real image ID (e.g. 123)
    
    const realImageId = 123;  // Suppose the server responds with this

    // Merge final data in place without removing the item
    setImages((prevImages) =>
      prevImages.map((item) => {
        if (item.id !== tmpId) return item;
        
        // E.g. update the existing item with final data
        return {
          ...item,
          id: realImageId,        // Overwrite the ID from `tmpId` → `realImageId`
          status: "done",
          url: "https://final-cdn-url/...",
          width: serverWidth,
          height: serverHeight,
          localUrl: undefined,    // Optional cleanup
        };
      })
    );
    
    // No .invalidateQueries() needed *just* for this one item
  } catch (err) {
    // Mark error in-place
    setImages((prev) =>
      prev.map((item) =>
        item.id === tmpId
          ? { ...item, status: "error", progress: 0 }
          : item
      )
    );
  }
}
Key Point: You never remove the item with tmpId. Instead, you replace its ID with the new one from the server. This preserves the React element key across pending → final states, so there’s no flicker or reorder.