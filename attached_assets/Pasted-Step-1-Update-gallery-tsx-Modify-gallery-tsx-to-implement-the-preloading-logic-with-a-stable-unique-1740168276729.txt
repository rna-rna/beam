Step 1: Update gallery.tsx
Modify gallery.tsx to implement the preloading logic with a stable uniqueId, ensuring /optimized preloads once when /thumb is visible.
Add uniqueId to ImageOrPending Type:
Update the type definition to include a persistent uniqueId.
tsx
interface ImageOrPending {
  id: number | string;
  uniqueId?: string; // Persistent ID for preloading
  url?: string;
  localUrl?: string;
  originalFilename?: string;
  status?: "uploading" | "complete" | "error";
  progress?: number;
  width?: number;
  height?: number;
  // ... other fields like userStarred, commentCount, etc. ...
}
Update preloadedImages to Set<string>:
Change the state declaration to use strings for consistency with uniqueId.
tsx
const [preloadedImages, setPreloadedImages] = useState<Set<string>>(new Set());
Update onDrop to Assign uniqueId:
Assign a uniqueId using nanoid() when adding new images.
tsx
const onDrop = useCallback(
  async (acceptedFiles: File[]) => {
    console.log("Files dropped:", acceptedFiles.length);
    if (acceptedFiles.length === 0) return;

    const totalSize = acceptedFiles.reduce((sum, file) => sum + file.size, 0);
    const batchId = nanoid();
    addBatch(batchId, totalSize, acceptedFiles.length);
    setGlobalBatchId(batchId);

    const limit = pLimit(3);

    const uploadPromises = acceptedFiles.map(async (file) => {
      const localUrl = URL.createObjectURL(file);

      return new Promise<void>((resolve) => {
        const imageEl = new Image();
        imageEl.onload = () => {
          const width = imageEl.naturalWidth;
          const height = imageEl.naturalHeight;

          const newItem: ImageOrPending = {
            id: file.name, // Temporary ID
            uniqueId: nanoid(), // Persistent unique ID
            localUrl,
            status: "uploading",
            progress: 0,
            width,
            height,
          };

          setImages((prev) => [...prev, newItem]);

          limit(() => uploadSingleFile(file, batchId))
            .then(resolve)
            .catch((error) => {
              console.error("Upload failed:", error);
              setImages((prev) =>
                prev.map((img) =>
                  img.id === file.name
                    ? { ...(img as PendingImage), status: "error", progress: 0 }
                    : img
                )
              );
              resolve();
            });
        };
        imageEl.src = localUrl;
      });
    });

    try {
      await Promise.all(uploadPromises);
      console.log("All uploads completed");
      completeBatch(batchId, true);
      queryClient.invalidateQueries({
        queryKey: [`/api/galleries/${slug}`],
        exact: true,
        refetchType: "all",
      });
    } catch (error) {
      console.error("Batch upload error:", error);
      completeBatch(batchId, false);
      toast({
        title: "Upload Error",
        description: "Some files failed to upload. Please try again.",
        variant: "destructive",
      });
    }
  },
  [setImages, uploadSingleFile, queryClient, slug, addBatch, completeBatch],
);
Update uploadSingleFile to Preserve uniqueId:
Ensure the uniqueId persists when updating the image with server data.
tsx
const uploadSingleFile = (file: File, batchId: string): Promise<void> => {
  return new Promise(async (resolve, reject) => {
    console.log("Starting upload process:", {
      fileName: file.name,
      fileSize: `${(file.size / (1024 * 1024)).toFixed(2)}MB`,
      fileType: file.type,
      batchId: batchId,
      timestamp: new Date().toISOString(),
    });

    try {
      const token = await getToken();
      const response = await fetch(`/api/galleries/${slug}/images`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          files: [
            {
              name: file.name,
              type: file.type,
              size: file.size,
            },
          ],
        }),
      });

      if (!response.ok) throw new Error("Failed to get upload URL");

      const { urls } = await response.json();
      const { signedUrl, publicUrl, imageId } = urls[0];

      // Preserve uniqueId while updating to server ID
      setImages((prev) =>
        prev.map((img) =>
          img.id === file.name
            ? {
                ...img,
                id: imageId,
                uniqueId: img.uniqueId, // Preserve uniqueId
                status: "uploading",
                progress: 0,
              }
            : img,
        ),
      );

      // ... rest of upload logic (XHR upload) ...

      const img = new Image();
      img.onload = () => {
        setImages((prev) =>
          prev.map((img) =>
            img.id === imageId
              ? {
                  ...(img as PendingImage),
                  status: "complete",
                  progress: 100,
                }
              : img,
          ),
        );
      };
      img.src = publicUrl;
      resolve();
    } catch (error) {
      setImages((prev) =>
        prev.map((img) =>
          img.id === file.name
            ? { ...(img as PendingImage), status: "error", progress: 0 }
            : img,
        ),
      );
      console.error("Upload failed:", error);
      reject(error);
    }
  });
};
Update preloadImage Function:
Use uniqueId for tracking and ensure it preloads /optimized.
tsx
const preloadImage = useCallback((image: ImageOrPending, uniqueId: string) => {
  if (preloadedImages.has(uniqueId)) return;
  const optimizedUrl = "localUrl" in image ? image.localUrl : getR2Image(image, "lightbox");
  console.log("Preloading optimized image:", optimizedUrl);
  const img = new Image();
  img.src = optimizedUrl;
  img.onload = () => {
    setPreloadedImages((prev) => new Set([...Array.from(prev), uniqueId]));
  };
}, [preloadedImages, getR2Image]);
Update ImageComponent:
Use uniqueId for keys and preloading, ensuring /thumb triggers /optimized.
tsx
const ImageComponent = memo(({ image, index }: { image: ImageOrPending; index: number }) => {
  const uniqueId = useMemo(() => 
    "uniqueId" in image ? image.uniqueId : `server-${image.id}`, 
    [image]
  );
  
  const optimizedUrl = useMemo(() => 
    "localUrl" in image ? image.localUrl : getR2Image(image, "lightbox"),
    [image]
  );

  const hasPreloadedRef = useRef(false);

  const preloadCallback = useCallback(() => {
    if (hasPreloadedRef.current || preloadedImages.has(uniqueId)) {
      return;
    }
    hasPreloadedRef.current = true;
    preloadImage(image, uniqueId);
  }, [image, uniqueId]);

  const intersectionRef = useIntersectionPreload(preloadCallback);

  return (
    <div
      ref={intersectionRef}
      key={uniqueId}
      className="mb-4 w-full"
      style={{ breakInside: "avoid", position: "relative" }}
    >
      <motion.div
        layout={false}
        className={cn(
          "image-container transform transition-opacity duration-200 w-full",
          isReorderMode && "cursor-grab active:cursor-grabbing",
          draggedItemIndex === index ? "fixed" : "relative",
          "localUrl" in image && "opacity-80",
          "block",
        )}
        initial={{ opacity: 0 }}
        animate={{
          opacity: 1,
          transition: { duration: 0.2 },
        }}
        drag={isReorderMode}
        dragMomentum={false}
        dragElastic={0.1}
        onDragStart={() => setDraggedItemIndex(index)}
        onDrag={(_, info) => {
          setDragPosition({ x: info.point.x, y: info.point.y });
        }}
        onDragEnd={(event, info) => handleDragEnd(event as PointerEvent, index, info)}
      >
        <div
          className={`group relative bg-card rounded-lg transform transition-all ${
            !isReorderMode ? "hover:scale-[1.02] cursor-pointer" : ""
          } ${selectMode ? "hover:scale-100" : ""} ${
            isReorderMode ? "border-2 border-dashed border-gray-200 border-opacity-50" : ""
          }`}
          onClick={(e) => {
            if (isReorderMode) {
              e.stopPropagation();
              return;
            }
            selectMode ? handleImageSelect(image.id, e) : handleImageClick(index);
          }}
        >
          <img
            key={`${uniqueId}-${image.status || "final"}`}
            src={"localUrl" in image ? image.localUrl : getR2Image(image, "thumb")}
            alt={image.originalFilename || "Uploaded image"}
            className={cn(
              "w-full h-auto rounded-lg blur-up transition-opacity duration-200 object-contain",
              selectMode && selectedImages.includes(image.id) && "opacity-75",
              draggedItemIndex === index && "opacity-50",
              "localUrl" in image && "opacity-80",
              image.status === "error" && "opacity-50",
            )}
            loading="lazy"
            onLoad={(e) => e.currentTarget.classList.add("loaded")}
            onError={(e) => {
              if (!("localUrl" in image)) e.currentTarget.src = "/fallback-image.jpg";
            }}
            draggable={false}
          />
          {/* ... rest of your JSX (progress indicators, stars, etc.) ... */}
        </div>
      </motion.div>
    </div>
  );
}, [preloadImage, isReorderMode, selectMode, handleImageSelect, handleImageClick, draggedItemIndex, handleDragEnd, selectedImages]);
Remove Redundant Preload in useEffect:
The existing useEffect for preloading gallery images is unnecessary since ImageComponent handles it. Remove or adjust it:
tsx
// Remove this useEffect or adjust it to not preload unnecessarily
useEffect(() => {
  if (gallery?.images) {
    gallery.images.forEach((image) => {
      const uniqueId = `server-${image.id}`;
      if (!preloadedImages.has(uniqueId)) {
        preloadImage(image, uniqueId);
      }
    });
  }
}, [gallery?.images, preloadImage]);
Step 2: Verify useIntersectionPreload.tsx
The current version is sufficient, but ensure it’s stable:
tsx
import { useRef, useEffect } from "react";

export function useIntersectionPreload(
  callback: () => void,
  options?: IntersectionObserverInit
) {
  const ref = useRef<HTMLDivElement | null>(null);
  const observerRef = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    if (!ref.current) return;

    if (observerRef.current) {
      observerRef.current.disconnect();
    }

    observerRef.current = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting) {
        callback();
        observerRef.current?.disconnect();
      }
    }, options);

    observerRef.current.observe(ref.current);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [callback, options]);

  return ref;
}
Note: This disconnects after firing, which is correct. The callback dependency ensures it updates if the image changes (e.g., during upload swap).
Step 3: Test and Verify
Console Logs:
Open your gallery and scroll. Check the console for "Preloading optimized image:". It should log exactly once per image when its /thumb version enters the viewport.
Example: Preloading optimized image: https://w.beam.ms/optimized/... should appear once per unique image.
Upload Flow:
Drop an image. The thumbnail should initially be a blob: URL. After upload completes (server ID assigned), scroll it into view and confirm /optimized preloads once.
Lightbox Check:
Click a thumbnail after it’s been visible. The lightbox should display the /optimized image instantly (cached from preload). Use browser DevTools (Network tab) to confirm no new fetch occurs for /optimized.
Debug Re-renders:
Add a debug log in ImageComponent:
tsx
useEffect(() => {
  console.log(`ImageComponent mounted: ${uniqueId}`);
  return () => console.log(`ImageComponent unmounted: ${uniqueId}`);
}, [uniqueId]);
Ensure it mounts once and doesn’t remount unnecessarily unless the image data changes.
Step 4: Adjust if Needed
If Preloading Still Repeats:
Check if ImageComponent is re-rendering excessively (e.g., due to parent state changes like isMasonry). Adjust memo dependencies or use a useEffect to log prop changes.
If Lightbox Isn’t Using Preloaded Image:
Verify the URL matches exactly between preloadCallback (getR2Image(image, "lightbox")) and lightbox (getR2Image(selectedImage, "lightbox")).
