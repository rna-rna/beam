Objective for Replit: Fix Drag-and-Drop Reorder for Free Movement Across the Entire Grid
Current Problem (Why Drag Isn’t Working):
Drag Constrained to Y-Axis Only

The current drag logic allows vertical movement (y-axis) but restricts horizontal movement (x-axis).
This limitation causes dragging to only work within the same column.
Drag Drop Calculation (Incorrect Target Calculation)

The code calculates the drop position by measuring y-axis distance, failing to account for grid-based horizontal movement.
Trello-like dragging requires tracking both x and y coordinates dynamically during drag.
Dynamic Grid Shift Not Triggering

Framer Motion’s layout is in use, but the grid isn’t dynamically adjusting to incoming items during the drag.
Drop zones aren't highlighted or visibly responsive to drag movement.
Proposed Fix (Trello-Like Reorder Behavior):
Free Movement Across X and Y Axes:
Allow unrestricted movement within the entire gallery grid.
Dynamic Drop Zone Adjustment:
Shift grid items dynamically as the dragged item hovers over different areas.
Placeholder Feedback:
Highlight the target drop zone as the item is dragged.
Implementation Instructions for Replit:
1. Remove Vertical Drag Constraints – Allow Full Drag
Modify the current drag logic to allow unrestricted movement across both axes.

Update the Dragging Behavior in renderImage:

tsx
Copy code
<motion.div
  key={image.id}
  layout
  drag={isReorderMode ? true : false}  // Enable free drag
  dragConstraints={false}  // Remove constraints
  dragElastic={0.2}  // Slight elasticity to soften drag
  onDragEnd={(event, info) => handleDragEnd(event, index, info)}
  whileDrag={{
    scale: 1.05,
    zIndex: 50,
    boxShadow: "0 10px 20px rgba(0,0,0,0.1)",
  }}
  className="image-container relative cursor-grab"
>
2. Dynamic Drop Zone Calculation
Update the logic to calculate x and y positions instead of just y-axis.
Use clientX and clientY to track mouse/finger position during drag.
Fix handleDragEnd to Calculate Based on Grid Position:

tsx
Copy code
const handleDragEnd = useCallback((
  event: MouseEvent | TouchEvent | PointerEvent,
  draggedIndex: number,
  info: PanInfo
) => {
  if (!gallery || !isReorderMode) return;

  const galleryItems = Array.from(document.querySelectorAll(".image-container"));

  let targetIndex = draggedIndex;
  let closestDistance = Infinity;
  const { clientX, clientY } = event;  // Get the mouse/finger position

  galleryItems.forEach((item, index) => {
    const rect = item.getBoundingClientRect();
    const itemCenterX = rect.left + rect.width / 2;
    const itemCenterY = rect.top + rect.height / 2;
    
    const distance = Math.hypot(itemCenterX - clientX, itemCenterY - clientY);
    
    if (distance < closestDistance && index !== draggedIndex) {
      closestDistance = distance;
      targetIndex = index;
    }
  });

  if (targetIndex !== draggedIndex) {
    const updatedImages = [...gallery.images];
    const [movedImage] = updatedImages.splice(draggedIndex, 1);
    updatedImages.splice(targetIndex, 0, movedImage);

    queryClient.setQueryData([`/api/galleries/${slug}`], {
      ...gallery,
      images: updatedImages,
    });

    reorderImageMutation.mutate(updatedImages.map(img => img.id));
  }
}, [gallery, isReorderMode, queryClient, reorderImageMutation, slug]);
3. Add Placeholder Feedback (Simulate Drop Target)
Introduce highlighted placeholders that temporarily show the drag destination.

Modify renderImage to Add Drop Placeholder:

tsx
Copy code
{gallery?.images.map((image: Image, index: number) => (
  <motion.div
    key={image.id}
    layout
    animate={{ scale: isReorderMode ? 0.95 : 1 }}
    whileDrag={{ scale: 1.05 }}
    className={`relative cursor-pointer image-container ${
      isReorderMode ? "border border-dashed border-gray-400" : ""
    }`}
  >
    <img
      src={image.url}
      alt=""
      className="w-full h-auto object-cover rounded-lg"
    />
  </motion.div>
))}
4. Persistent Reorder Mode (Keep Mode Active After Dragging)
Ensure Reorder Mode stays active until the user exits manually.
Remove premature exits from drag handlers.
Update toggleReorderMode to Prevent Early Exits:

tsx
Copy code
const toggleReorderMode = () => {
  setIsReorderMode(!isReorderMode);
};
