Steps to Fix the Issue
To ensure redundant requests are avoided, hereâ€™s how you can update your current logic:

1. Prevent Redundant Upload Requests
Update the onDrop function in UploadDropzone to maintain a unique identifier (e.g., uploadId) for each active upload session. Use this to ensure only one session can proceed at a time.

javascript
Copy code
const [currentUploadId, setCurrentUploadId] = useState<string | null>(null);

const onDrop = useCallback(async (acceptedFiles: File[]) => {
  if (isUploading || currentUploadId) {
    console.log('[Upload] Skipping upload: another upload is in progress.');
    return;
  }

  try {
    if (!acceptedFiles?.length) {
      toast({
        title: 'No files selected',
        description: 'Please upload valid image files.',
        variant: 'destructive',
      });
      return;
    }

    // Generate a unique ID for this upload session
    const uploadId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    setCurrentUploadId(uploadId);

    // Validate file types and sizes
    const invalidFiles = acceptedFiles.filter(
      file => !file.type.startsWith('image/') || file.size > 10 * 1024 * 1024
    );

    if (invalidFiles.length) {
      toast({
        title: 'Invalid files detected',
        description: 'Please only upload images under 10MB in size.',
        variant: 'destructive',
      });
      setCurrentUploadId(null);
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);

    // Request signed URLs
    const { urls } = await requestSignedUrls(acceptedFiles);

    for (let i = 0; i < acceptedFiles.length; i++) {
      const file = acceptedFiles[i];
      const { signedUrl } = urls[i];

      const response = await fetch(signedUrl, {
        method: 'PUT',
        headers: { 'Content-Type': file.type },
        body: file,
      });

      if (!response.ok) {
        throw new Error(`Failed to upload ${file.name}: ${response.status} ${response.statusText}`);
      }

      console.log(`[Upload] Successfully uploaded: ${file.name}`);
      setUploadProgress(((i + 1) / acceptedFiles.length) * 100);
    }

    toast({
      title: 'Upload complete',
      description: 'All files were successfully uploaded.',
    });

    onUpload(acceptedFiles);
  } catch (error) {
    console.error('[Upload Error]:', error);
    toast({
      title: 'Upload failed',
      description: error.message || 'Upload failed. Please try again.',
      variant: 'destructive',
    });
  } finally {
    setIsUploading(false);
    setUploadProgress(0);
    setCurrentUploadId(null); // Clear the upload session
  }
}, [onUpload, isUploading, currentUploadId]);
