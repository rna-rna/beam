Diagnosis – Why the Zoom and Pan are Breaking
Upon analyzing the latest code, the following issues are causing erratic zoom/pan behavior:

Double-Tap Reset Doesn't Recentre
resetZoom correctly resets the scale and offset (offsetX, offsetY) to 0. However, the image remains in its panned position because the motion.div or motion.img does not animate to the center after the reset.
Edge Overflow Doesn't Smoothly Trigger Next Image
The current logic detects overflow (overflowX) but immediately switches to the next image once the threshold is crossed. This can feel abrupt and erratic.
Vertical Swipe to Close Doesn't Reveal Gallery Gradually
While vertical swipes trigger onClose(), the underlying gallery doesn’t gradually reveal as the swipe progresses. This leads to a harsh "snap-close" experience rather than a smooth, iOS-style dismiss animation.
Fix 1 – Double-Tap to Reset and Recentre
To recenter the image after a double-tap, animate offsetX and offsetY smoothly to 0:

tsx
Copy code
const resetZoom = () => {
  scaleValue.set(1);
  offsetX.set(0);
  offsetY.set(0);
  dragX.set(0);  // Reset gallery-level drag as well
  dragY.set(0);
};
Add animation for smooth centering:

tsx
Copy code
motion.img.animate({
  x: 0,
  y: 0,
  transition: { type: "spring", stiffness: 200, damping: 20 }
});
Fix 2 – Smooth Snap to Next Image (Edge Panning)
Instead of instantly switching images at the edge, implement inertia-based snapping to smoothly slide to the next image:

tsx
Copy code
const handlePan = (event: any, info: PanInfo) => {
  const scale = scaleValue.get();
  const maxX = (window.innerWidth / 2) * (scale - 1);
  const maxY = (window.innerHeight / 2) * (scale - 1);

  const newX = offsetX.get() + info.delta.x;
  const newY = offsetY.get() + info.delta.y;
  const overflowX = Math.abs(newX) - maxX;

  if (overflowX > 40) {
    // Apply inertia for smoother snap
    offsetX.set(newX * 1.2);
    setTimeout(() => {
      const nextIndex = currentIndex + (newX < 0 ? 1 : -1);
      const clampedIndex = Math.max(0, Math.min(nextIndex, images.length - 1));
      setCurrentIndex(clampedIndex);
      offsetX.set(0);
      offsetY.set(0);
    }, 100);
  } else {
    offsetX.set(clampPan(newX, maxX));
    offsetY.set(clampPan(newY, maxY));
  }
};
Fix 3 – Swipe Down to Dismiss with Background Reveal
To create a "reveal" effect for the gallery below as the image swipes down, gradually reduce the opacity of the black overlay (motion.div).

Modify the motion.div style:
tsx
Copy code
const revealOpacity = useTransform(dragY, [-200, 0, 200], [0.5, 1, 0]);  // Lower opacity during swipe
Apply this transform to the parent:

tsx
Copy code
<motion.div
  className="fixed inset-0 bg-black touch-none z-50 overflow-hidden"
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
  exit={{ opacity: 0 }}
  style={{ opacity: revealOpacity }}  // Apply dynamic opacity
/>
Fix 4 – Smooth Vertical Swipe to Close
Ensure vertical swipes reveal the gallery underneath while maintaining control:

tsx
Copy code
const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
  const xOffset = info.offset.x;
  const yOffset = info.offset.y;

  // Reveal background and dismiss if dragged far enough
  if (Math.abs(yOffset) > 150 && Math.abs(xOffset) < 50) {
    onClose();
    return;
  }

  dragX.set(0);
  dragY.set(0);
  setIsDragging(false);
};
Final Code Changes:
tsx
Copy code
const handlePan = (event: any, info: PanInfo) => {
  const scale = scaleValue.get();
  const maxX = (window.innerWidth / 2) * (scale - 1);
  const maxY = (window.innerHeight / 2) * (scale - 1);

  const newX = offsetX.get() + info.delta.x;
  const newY = offsetY.get() + info.delta.y;

  const overflowX = Math.abs(newX) - maxX;

  if (overflowX > 40) {
    offsetX.set(newX * 1.2);
    setTimeout(() => {
      const nextIndex = currentIndex + (newX < 0 ? 1 : -1);
      const clampedIndex = Math.max(0, Math.min(nextIndex, images.length - 1));
      setCurrentIndex(clampedIndex);
      offsetX.set(0);
      offsetY.set(0);
    }, 100);
  } else {
    offsetX.set(clampPan(newX, maxX));
    offsetY.set(clampPan(newY, maxY));
  }
};

const resetZoom = () => {
  scaleValue.set(1);
  offsetX.set(0);
  offsetY.set(0);
  dragX.set(0);  // Reset gallery drag
  dragY.set(0);
};

<motion.div
  className="fixed inset-0 bg-black touch-none z-50 overflow-hidden"
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
  exit={{ opacity: 0 }}
  style={{ opacity: revealOpacity }}
>
  <motion.div
    className="absolute inset-0 w-full h-full"
    style={{
      scale,
      opacity,
    }}
    drag={scaleValue.get() === 1}
    dragElastic={0.1}
    dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
    onDragEnd={handleDragEnd}
  >
    <motion.img
      src={images[currentIndex].url}
      className="w-full h-full object-contain select-none"
      draggable={false}
      style={{
        scale: scaleValue,
        x: offsetX,
        y: offsetY,
      }}
      drag={scaleValue.get() > 1}
      dragElastic={0.2}
      onPan={handlePan}
    />
  </motion.div>
</motion.div>
