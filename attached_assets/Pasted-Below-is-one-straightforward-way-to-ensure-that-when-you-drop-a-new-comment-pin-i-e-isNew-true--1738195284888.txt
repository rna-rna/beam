Below is one straightforward way to ensure that when you drop a new comment pin (i.e., isNew = true), the input field is automatically focused for typing.

What’s happening now?
Right now, your code does attempt to focus on the <Input> when isNew is true:

tsx
Copy
Edit
ref={(input) => {
  if (input && isNew) {
    // Use RAF for more reliable focus
    requestAnimationFrame(() => {
      input.focus();
    });
  }
}}
However, using a function ref like this can be flaky if React unmounts/remounts the input in certain render phases (and it can also conflict with the outside-click handler that might toggle isExpanded and isEditing).

A more reliable and conventional approach is:

Create a stable ref for the input using useRef.
Use a useEffect hook to focus the input whenever we enter the “editing”/“isNew” state.
Example fix
Key changes:

Use a single stable ref: const inputRef = useRef<HTMLInputElement>(null).
Use a useEffect that runs whenever isEditing becomes true (which for a new comment is set to isNew initially).
Remove the existing ref={(input) => ... } logic from <Input> and replace it with ref={inputRef}.
Below is a minimal diff showing only the relevant changes. You can adapt or copy the snippet in full.

diff
Copy
Edit
 import { useState, useRef, useEffect } from "react";
 // ... rest of imports

 export function CommentBubble({ 
   x, 
   y, 
   content, 
   author, 
   onSubmit, 
   isNew = false, 
   imageId,
   id,
   reactions = [],
   children,
   onPositionChange,
   parentId = null,
   timestamp,
   replies = []
 }: CommentBubbleProps) {
   // ...
   const [isEditing, setIsEditing] = useState(isNew);
   const [text, setText] = useState(content || "");
   // ...
+  const inputRef = useRef<HTMLInputElement>(null);

   // Focus automatically if we are in "editing" mode:
+  useEffect(() => {
+    if (isEditing) {
+      requestAnimationFrame(() => {
+        inputRef.current?.focus();
+      });
+    }
+  }, [isEditing]);

   return (
     <motion.div
       // ...
     >
       <div className="relative">
         <div className="w-6 h-6 rounded-full bg-primary flex items-center justify-center text-primary-foreground">
           <MessageCircle className="w-4 h-4" />
         </div>

         <Card
           // ...
         >
           {isEditing ? (
             <form
               onSubmit={async (e) => {
                 e.preventDefault();
                 // ...
               }}
             >
               <div className="flex items-center gap-2">
                 <UserAvatar
                   // ...
                 />
-                <Input
-                  ref={(input) => {
-                    if (input && isNew) {
-                      // Use RAF for more reliable focus
-                      requestAnimationFrame(() => {
-                        input.focus();
-                      });
-                    }
-                  }}
-                  // ...
-                />
+                <Input
+                  ref={inputRef}
+                  type="text"
+                  value={text}
+                  onChange={(e) => setText(e.target.value)}
+                  className="flex-1 h-10 px-4 bg-background/80 backdrop-blur-sm border-0 shadow-none rounded-full focus-visible:ring-1 focus-visible:ring-offset-0"
+                  placeholder={user ? "Add a comment" : "Please sign in to comment"}
+                  readOnly={!user}
+                  onClick={() => {
+                    if (!user) setShowAuthModal(true);
+                  }}
+                />
               </div>
             </form>
           ) : (
             // ...
           )}
         </Card>
       </div>

       {/* Auth modal, Emoji picker, etc. */}
     </motion.div>
   );
 }
Why this works better
Stable Ref: By using const inputRef = useRef(null), we avoid any potential unmount/remount race conditions with function refs.
useEffect: Ensures we only call focus() after the component has rendered, in a guaranteed lifecycle step.
isEditing: In your code, isEditing is toggled when it’s a new comment (isNew) or when the user clicks to edit. Focusing is logically tied to that “editing” state, so we watch [isEditing].
With this change, as soon as the “new comment” bubble is rendered (isNew=true → isEditing=true), React will render the <Input> and then run the effect to focus the input automatically—no extra clicking needed.