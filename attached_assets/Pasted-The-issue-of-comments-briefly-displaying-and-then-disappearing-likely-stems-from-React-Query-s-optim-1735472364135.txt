The issue of comments briefly displaying and then disappearing likely stems from React Query's optimistic updates combined with how the comments are refetched post-submission.

Identifying the Issue:
From the code in CommentBubble.tsx:

Optimistic Update (onMutate):
When a comment is submitted, an optimistic comment is added immediately:

tsx
Copy code
const optimisticComment = {
  id: Date.now(),
  content: newCommentText,
  xPosition: x,
  yPosition: y,
  author: {
    id: user.id,
    username: `${user.firstName} ${user.lastName}`.trim(),
    imageUrl: user.imageUrl
  },
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString()
};
queryClient.setQueryData([`/api/images/${imageId}/comments`], (old: any[] = []) => [
  ...old,
  optimisticComment
]);
Issue:

After the successful comment mutation (onSuccess), the query is invalidated:
tsx
Copy code
queryClient.invalidateQueries({ queryKey: [`/api/images/${imageId}/comments`] });
This causes the comments to refetch from the server, potentially excluding the optimistic comment if the server has not fully processed the new comment yet.
The comment might disappear if there's a delay between the POST request completing and the data becoming available via GET.
How to Fix It:
Solution 1: Delay Query Invalidation (Debounce or Timeout):
Delay the invalidation of the query slightly to ensure the server has processed the new comment.

tsx
Copy code
onSuccess: (data) => {
  setTimeout(() => {
    queryClient.invalidateQueries({ queryKey: [`/api/images/${imageId}/comments`] });
  }, 500);  // 500ms delay to ensure data sync
}
Solution 2: Update from Response Instead of Refetching:
Instead of refetching the entire comments list, append the new comment from the response directly to the cache.

tsx
Copy code
onSuccess: (data) => {
  queryClient.setQueryData([`/api/images/${imageId}/comments`], (old: any[] = []) => [
    ...old.filter((c) => c.id !== data.id),  // Remove old optimistic comment
    data  // Append the server response directly
  ]);
  setText("");
  setIsEditing(false);
  toast({
    title: "Comment added",
    duration: 2000
  });
}
Solution 3: Keep Optimistic Comment Until the Server Confirms It (Manual Removal):
Use a temporary optimistic flag and remove the comment only when the server confirms its existence.

tsx
Copy code
const optimisticComment = {
  id: Date.now(),
  content: newCommentText,
  xPosition: x,
  yPosition: y,
  author: {
    id: user.id,
    username: `${user.firstName} ${user.lastName}`.trim(),
    imageUrl: user.imageUrl
  },
  optimistic: true  // Mark this comment as optimistic
};

queryClient.setQueryData([`/api/images/${imageId}/comments`], (old: any[] = []) => [
  ...old,
  optimisticComment
]);

onSuccess: (data) => {
  queryClient.setQueryData([`/api/images/${imageId}/comments`], (old: any[] = []) => {
    return old.map((comment) =>
      comment.optimistic ? { ...data, optimistic: false } : comment
    );
  });
};
Solution 4: Adjust Backend Response Timing (Less Ideal):
Ensure the backend responds to the POST request only after the database fully processes the comment. This avoids the need to refetch immediately.
