I need you to help me fix an issue in my React application where image preloading with an Intersection Observer is triggering repeatedly for the same image, causing "rapid repeating spam" in the console. The images should preload only once when they enter the viewport. My app uses locally stored images (e.g., blob URLs) on the frontend during upload, then swaps them for server-side versions once the upload completes. This local-to-server swap must be preserved. Below are the relevant files and logs. Please update the code to ensure stable keys and centralized preload tracking while maintaining this functionality.

---

### gallery.tsx (Current Code Snippet)
This is a simplified version of my Gallery component focusing on image rendering, preloading, and the local-to-server swap:

```tsx
import { memo, useCallback, useMemo, useState, useEffect } from "react";
import { useIntersectionPreload } from "@/hooks/useIntersectionPreload";
import { getR2Image } from "@/lib/r2";
import Masonry from "react-masonry-css";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface ImageOrPending {
  id: number | string;
  url?: string;
  localUrl?: string;
  originalFilename?: string;
  status?: "uploading" | "complete" | "error";
  progress?: number;
}

export default function Gallery({ slug }: { slug?: string }) {
  const [images, setImages] = useState<ImageOrPending[]>([]);
  const [preloadedImages, setPreloadedImages] = useState<Set<number>>(new Set());
  const [isMasonry, setIsMasonry] = useState(true);

  // Simulated upload and swap logic
  const onDrop = useCallback((files: File[]) => {
    const newImages = files.map(file => ({
      id: file.name, // Temporary ID
      localUrl: URL.createObjectURL(file),
      originalFilename: file.name,
      status: "uploading",
      progress: 0,
    }));
    setImages(prev => [...prev, ...newImages]);

    // Simulate server response after 2 seconds
    setTimeout(() => {
      setImages(prev =>
        prev.map(img =>
          "localUrl" in img && img.id === files[0].name
            ? { id: 1, url: "server-image.jpg", originalFilename: img.originalFilename }
            : img
        )
      );
    }, 2000);
  }, []);

  // Simulated drop trigger
  useEffect(() => {
    onDrop([new File([""], "test.jpg")]);
  }, [onDrop]);

  const ImageComponent = memo(({ image, index }: { image: ImageOrPending; index: number }) => {
    const [hasPreloaded, setHasPreloaded] = useState(false);
    const imageId = useMemo(() => "localUrl" in image ? image.localUrl : image.id, [image]);
    const optimizedUrl = useMemo(() => "localUrl" in image ? image.localUrl : getR2Image(image, "lightbox"), [image]);

    const preloadCallback = useCallback(() => {
      if (hasPreloaded) return;
      setHasPreloaded(true);
      console.log("Preloading optimized image:", optimizedUrl);
      const img = new Image();
      img.src = optimizedUrl;
    }, [hasPreloaded, optimizedUrl]);

    const intersectionRef = useIntersectionPreload(preloadCallback);

    return (
      <div
        ref={intersectionRef}
        key={image.id === -1 ? `pending-${index}` : image.id}
        className="mb-4 w-full"
        style={{ breakInside: "avoid", position: "relative" }}
      >
        <motion.div className={cn("image-container")}>
          <img
            src={"localUrl" in image ? image.localUrl : getR2Image(image, "thumb")}
            alt={image.originalFilename || "Uploaded image"}
            className="w-full h-auto"
            loading="lazy"
          />
          {"localUrl" in image && <span>Uploading: {image.progress}%</span>}
        </motion.div>
      </div>
    );
  });

  const breakpointCols = { default: 3, 1024: 2, 768: 1 };

  return (
    <div>
      {isMasonry ? (
        <Masonry breakpointCols={breakpointCols} className="flex -ml-4">
          {images.map((image, index) => <ImageComponent key={image.id} image={image} index={index} />)}
        </Masonry>
      ) : (
        <div className="grid gap-4" style={{ gridTemplateColumns: "repeat(3, minmax(0, 1fr))" }}>
          {images.map((image, index) => <ImageComponent key={image.id} image={image} index={index} />)}
        </div>
      )}
    </div>
  );
}
useIntersectionPreload.ts (Current Code)
ts
import { useRef, useEffect } from "react";

export function useIntersectionPreload(
  callback: () => void,
  options?: IntersectionObserverInit
) {
  const ref = useRef<HTMLDivElement | null>(null);
  const hasPreloaded = useRef(false);
  const callbackRef = useRef(callback);

  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    if (!ref.current || hasPreloaded.current) return;

    const observer = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting && !hasPreloaded.current) {
        hasPreloaded.current = true;
        callbackRef.current();
        observer.disconnect();
      }
    }, options);

    observer.observe(ref.current);
    return () => observer.disconnect();
  }, [options]);

  return ref;
}
Browser Logs
Here are the logs showing the issue:
react_jsx-dev-runtime.js:64 Warning: Each child in a list should have a unique "key" prop.
Gallery.tsx:1853 Preloading optimized image: blob:https://.../bfff918a-8e65-4794-9ffa-c3da04d843f2
Gallery.tsx:377 New image uploaded: Object
Gallery.tsx:1853 Preloading optimized image: blob:https://.../bfff918a-8e65-4794-9ffa-c3da04d843f2
Gallery.tsx:1252 Upload progress: Object
Gallery.tsx:1853 Preloading optimized image: blob:https://.../bfff918a-8e65-4794-9ffa-c3da04d843f2
Gallery.tsx:1284 Upload complete: Object
Gallery.tsx:1404 All uploads completed
Gallery.tsx:1853 Preloading optimized image: blob:https://.../bfff918a-8e65-4794-9ffa-c3da04d843f2
Gallery.tsx:1853 Preloading optimized image: blob:https://.../bfff918a-8e65-4794-9ffa-c3da04d843f2
The "Preloading optimized image:" log repeats multiple times for the same blob: URL.
There’s a React key warning indicating potential key instability.
Requirements
Ensure each image preloads only once when it enters the viewport.
Fix the React key warning by using stable, unique keys that persist through the local-to-server swap (e.g., use a consistent identifier across both states).
Centralize preload tracking in the parent Gallery component using preloadedImages with string type to handle both blob: URLs and server IDs.
Preserve the local-to-server swap: images start with localUrl and switch to url when the server responds, without breaking rendering or preloading.
Update ImageComponent and useIntersectionPreload accordingly.
Instructions
Please rewrite gallery.tsx and useIntersectionPreload.ts to:
Use a stable uniqueId for keys that remains consistent during the local-to-server swap (e.g., base it on originalFilename or a generated ID, not localUrl or id alone).
Move preload tracking to the parent’s preloadedImages Set, using uniqueId to track preloads.
Simplify useIntersectionPreload to disconnect after firing, relying on parent state.
Ensure ImageComponent is memoized and handles the swap from localUrl to url seamlessly.
Keep the upload simulation (onDrop) intact to demonstrate the swap.
Provide the updated code for both files.

---

### Expected Output from Claude Sonnet

Here’s what Claude might generate, adapted to preserve the local-to-server swap:

#### Updated `gallery.tsx`
```tsx
import { memo, useCallback, useMemo, useState, useEffect } from "react";
import { useIntersectionPreload } from "@/hooks/useIntersectionPreload";
import { getR2Image } from "@/lib/r2";
import Masonry from "react-masonry-css";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";
import { nanoid } from "nanoid";

interface ImageOrPending {
  id: number | string; // Temporary ID during upload, server ID after
  uniqueId: string; // Persistent ID across swap
  url?: string;
  localUrl?: string;
  originalFilename?: string;
  status?: "uploading" | "complete" | "error";
  progress?: number;
}

export default function Gallery({ slug }: { slug?: string }) {
  const [images, setImages] = useState<ImageOrPending[]>([]);
  const [preloadedImages, setPreloadedImages] = useState<Set<string>>(new Set());
  const [isMasonry, setIsMasonry] = useState(true);

  const onDrop = useCallback((files: File[]) => {
    const newImages = files.map(file => ({
      id: file.name, // Temporary ID
      uniqueId: nanoid(), // Persistent unique ID
      localUrl: URL.createObjectURL(file),
      originalFilename: file.name,
      status: "uploading",
      progress: 0,
    }));
    setImages(prev => [...prev, ...newImages]);

    setTimeout(() => {
      setImages(prev =>
        prev.map(img =>
          "localUrl" in img && img.id === files[0].name
            ? { 
                ...img, 
                id: 1, 
                url: "server-image.jpg", 
                localUrl: undefined, 
                status: "complete", 
                progress: 100 
              }
            : img
        )
      );
    }, 2000);
  }, []);

  useEffect(() => {
    onDrop([new File([""], "test.jpg")]);
  }, [onDrop]);

  const preloadImage = useCallback((image: ImageOrPending, uniqueId: string) => {
    if (preloadedImages.has(uniqueId)) return;
    const optimizedUrl = "localUrl" in image ? image.localUrl : getR2Image(image, "lightbox");
    console.log("Preloading optimized image:", optimizedUrl);
    const img = new Image();
    img.src = optimizedUrl;
    img.onload = () => {
      setPreloadedImages((prev) => new Set([...Array.from(prev), uniqueId]));
    };
    img.onerror = () => {
      console.error("Failed to preload image:", optimizedUrl);
    };
  }, [preloadedImages, getR2Image]);

  const ImageComponent = memo(({ image, index }: { image: ImageOrPending; index: number }) => {
    const preloadCallback = useCallback(() => {
      preloadImage(image, image.uniqueId);
    }, [image]);

    const intersectionRef = useIntersectionPreload(preloadCallback);

    return (
      <div
        ref={intersectionRef}
        key={image.uniqueId}
        className="mb-4 w-full"
        style={{ breakInside: "avoid", position: "relative" }}
      >
        <motion.div className={cn("image-container")}>
          <img
            src={"localUrl" in image ? image.localUrl : getR2Image(image, "thumb")}
            alt={image.originalFilename || "Uploaded image"}
            className="w-full h-auto"
            loading="lazy"
          />
          {"localUrl" in image && <span>Uploading: {image.progress}%</span>}
        </motion.div>
      </div>
    );
  }, [preloadImage]);

  const breakpointCols = { default: 3, 1024: 2, 768: 1 };

  return (
    <div>
      {isMasonry ? (
        <Masonry breakpointCols={breakpointCols} className="flex -ml-4">
          {images.map((image, index) => <ImageComponent key={image.uniqueId} image={image} index={index} />)}
        </Masonry>
      ) : (
        <div className="grid gap-4" style={{ gridTemplateColumns: "repeat(3, minmax(0, 1fr))" }}>
          {images.map((image, index) => <ImageComponent key={image.uniqueId} image={image} index={index} />)}
        </div>
      )}
    </div>
  );
}
Updated useIntersectionPreload.ts
ts
import { useRef, useEffect } from "react";

export function useIntersectionPreload(
  callback: () => void,
  options?: IntersectionObserverInit
) {
  const ref = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting) {
        callback();
        observer.disconnect();
      }
    }, options);

    observer.observe(ref.current);
    return () => observer.disconnect();
  }, [callback, options]);

  return ref;
}
Key Adjustments for Local-to-Server Swap
Persistent uniqueId:
Added a uniqueId field (generated with nanoid()) to each image when it’s created in onDrop. This ID remains constant across the local-to-server swap, ensuring stable keys and consistent preloading tracking.
The id field still updates from file.name to the server’s numeric ID (e.g., 1), but the key uses uniqueId.
Preload Tracking:
preloadedImages uses uniqueId (a string) to track preloads, ensuring that an image is preloaded only once, whether it’s using localUrl or url.
Swap Preservation:
The onDrop handler keeps the local blob: URL in localUrl initially, then updates the image object to use url from the server, clearing localUrl. The img.src logic ("localUrl" in image ? image.localUrl : getR2Image(image, "thumb")) ensures seamless rendering.
Memoization:
ImageComponent is memoized with preloadImage as a dependency, ensuring the callback is stable. The image prop changes during the swap, but uniqueId keeps the component identity intact.
