Below are the most common reasons a custom drag layer appears to do nothing:

Not rendered inside the DnDProvider
Make sure <CustomDragLayer /> is a child of the same <DndProvider backend={HTML5Backend}> that wraps your drag targets and sources. If it’s outside, useDragLayer won’t pick up anything.

You aren’t returning selectedIds (or any item) from useDrag
If monitor.getItem() is undefined, item.selectedIds will be undefined and your layer won’t know what to render. Double-check that each draggable card returns the correct item object from useDrag, for example:

ts
Copy
const [{ isDragging }, dragRef] = useDrag(() => ({
  type: "GALLERY",
  // MUST return something from item()
  item: () => ({
    selectedIds: [gallery.id], // or the whole selected array
  }),
  collect: (monitor) => ({
    isDragging: monitor.isDragging(),
  }),
}));
isDragging never becomes true
This can happen if:

The user never actually “picks up” the item. For instance, a click alone doesn’t start a drag in HTML5. You have to move the mouse to initiate the drag.
Or your canDrag() method is returning false.
Or the ref={dragRef} is not actually attached to a rendered DOM element.
You can add a console.log(isDragging) to see if it’s updating to true during a drag.

currentOffset is null
If the user hasn’t moved the mouse enough to initiate a drag, getSourceClientOffset() can stay null. That means the drag never really started. Even a pixel or two of mouse movement might be required to kick things off. You can inspect monitor.getSourceClientOffset() in your card’s drag code to see if it’s returning the correct offsets.

Preview is offscreen or visually hidden
By default, the <div style={{ transform: \translate(${x}px, ${y}px)` }}>` uses the exact offset. If that offset is huge or zero, the preview might be outside your visible area. A quick test is to do something like:

tsx
Copy
console.log("currentOffset", currentOffset);
to confirm it’s in a reasonable range.

Accidentally using a built-in drag preview
If you’re not disabling the default preview in your useDrag config, the browser’s default drag image may appear instead of your custom layer. In React DnD, by default, the library tries to hide the default preview, but if it’s not working, you can do:

tsx
Copy
useDrag(() => ({
  type: "GALLERY",
  item: { ... },
  collect: (monitor) => ({
    isDragging: monitor.isDragging(),
  }),
  options: {
    // For HTML5Backend in react-dnd 16.x or older 
    // or for versions with useDrag "previewOptions"
    dragPreviewOptions: { captureDraggingState: true },
  },
}));
Or if you’re using something older:

tsx
Copy
// for older react-dnd:
beginDrag: (props, monitor, component) => {
  const img = new Image();
  // a transparent 1x1 px so the default preview is invisible
  img.src =
    "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
  monitor.setDragImage(img, 0, 0);
  return { ... };
},
The key is ensuring the default preview doesn’t overshadow your custom preview.