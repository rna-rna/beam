Below is a step‐by‐step guide to integrate @dnd-kit into your masonry gallery for a more flexible reordering system. The key points are:

Wrap your list of images in a DndContext.
Render each image as a draggable item.
Implement a drag overlay (the “ghost” item) for a nice smaller preview.
Write a custom or semi‐custom collision detection so you can handle the “where does it drop?” logic in a masonry layout.
Because a masonry layout has different item heights, you typically need custom collision or advanced strategies. Below is a simplified approach you can adapt.

1) Install and Import
bash
Copy
Edit
# Using npm:
npm install @dnd-kit/core

# or yarn:
yarn add @dnd-kit/core
In your code:

ts
Copy
Edit
import {
  DndContext,
  useDraggable,
  useDroppable,
  DragOverlay,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
  rectIntersection,
  // or any other collision detection, e.g. closestCenter
} from '@dnd-kit/core';
2) Create a “DndContext” around your Images
In gallery.tsx (the core rendering of your images), do something like:

diff
Copy
Edit
function Gallery({ ...props }) {
  + const [activeId, setActiveId] = useState<number | null>(null);
  + const [images, setImages] = useState<ImageOrPending[]>([...] /* from your query */);

  // Setup dnd-kit sensors
  + const sensors = useSensors(
  +   useSensor(MouseSensor),
  +   useSensor(TouchSensor)
  + );

  // When drag ends, reorder in your state
  + function handleDragEnd(event) {
  +   const { active, over } = event;
  +   if (!over || active.id === over.id) {
  +     setActiveId(null);
  +     return;
  +   }

  +   const oldIndex = images.findIndex((img) => img.id === active.id);
  +   const newIndex = images.findIndex((img) => img.id === over.id);
  +   if (oldIndex < 0 || newIndex < 0) return;

  +   const updated = [...images];
  +   const [moved] = updated.splice(oldIndex, 1);
  +   updated.splice(newIndex, 0, moved);
  +   setImages(updated);

  +   // Optionally send updated order to server:
  +   // reorderImageMutation.mutate(updated.map((img) => img.id));
  +   setActiveId(null);
  + }

  return (
    <DndContext
  +   sensors={sensors}
      collisionDetection={rectIntersection} // or closestCenter, or a custom function
  +   onDragStart={(event) => setActiveId(event.active.id)}
  +   onDragEnd={handleDragEnd}
      onDragCancel={() => setActiveId(null)}
    >
      {/* Now render your masonry with draggable images */}
      ...

      {/* The special overlay that shows the “ghost” while dragging */}
      <DragOverlay>
        {activeId ? (
          <YourDragPreview itemId={activeId} images={images} />
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}
activeId holds the ID of the item being dragged.
collisionDetection determines how dnd-kit figures out which item you’re “over.” For a variable‐height layout, rectIntersection is a decent start, though you may want to customize further.
DragOverlay is a special portal to render a custom “ghost” element. If activeId is set, we render that ghost.