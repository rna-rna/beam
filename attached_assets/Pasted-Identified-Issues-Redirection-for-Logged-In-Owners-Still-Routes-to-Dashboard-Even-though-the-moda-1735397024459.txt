Identified Issues:
Redirection for Logged-In Owners Still Routes to Dashboard:

Even though the modal (AuthModal.tsx) correctly sets the redirectUrl and afterSignInUrl, the problem might lie in how the redirect is handled post-authentication.
Clerk might still default to /dashboard or another generic route because afterSignInUrl is not overriding Clerk's default behavior.
Public Gallery Still Not Accessible for Unauthenticated Users:

The public route (/api/galleries/:slug) allows fetching gallery data, but the frontend logic might still restrict visibility.
Solutions and Modifications:
1. Clerk Redirection (Ensure Gallery Owners Stay on Page):
Issue:

Clerk might not prioritize redirectUrl consistently.
Even though the redirect logic exists in AuthModal.tsx, the backend may force /dashboard after successful login.
Solution:

Modify Clerk configuration to enforce the redirect path at the top level.
Update routes.ts to conditionally redirect based on ownership:
ts
Copy code
protectedRouter.get('/galleries/:slug', async (req: any, res) => {
  const userId = req.auth.userId;
  
  const gallery = await db.query.galleries.findFirst({
    where: eq(galleries.slug, req.params.slug),
  });

  if (!gallery) {
    return res.status(404).json({ message: 'Gallery not found' });
  }

  const isOwner = gallery.userId === userId;

  if (isOwner) {
    return res.redirect(`/galleries/${gallery.slug}`);
  }

  res.json(gallery); // Allow public users to fetch data
});
Ensure Clerk Uses Redirect Properly in AuthModal.tsx:

tsx
Copy code
const handleSignIn = () => {
  onClose();
  openSignIn({
    redirectUrl: redirectPath || window.location.pathname,
    afterSignInUrl: redirectPath || window.location.pathname
  });
};
2. Frontend Component Logic â€“ Handle Redirect After Login (React Side):
Issue:

After logging in, Clerk might route to /dashboard by default even if redirectPath is passed.
The gallery page may also prematurely redirect unauthenticated users.
Solution:

In GalleryView.tsx or the relevant component fetching the gallery, update the routing logic:
tsx
Copy code
const { canView, requiresAuth } = useGalleryPermissions(gallery.userId);

useEffect(() => {
  const { required, redirectPath } = requiresAuth('comment');

  if (required) {
    openModal({
      action: 'comment',
      redirectPath
    });
  }
}, [canView]);
3. Update Gallery Permissions to Avoid Unnecessary Redirects (Frontend Logic):
Issue:

The use-gallery-permissions.ts hook might unnecessarily block viewing for unauthenticated users.
Solution (Modify useGalleryPermissions):

ts
Copy code
return {
  canView: true,  // Always allow viewing even if not authenticated
  canEdit: isAuthenticated && isOwner,
  canComment: isAuthenticated,
  canStar: isAuthenticated,
  isAuthenticated,
  isOwner,
  requiresAuth,
  currentPath
};
4. Ensure Correct Auth Middleware Logic in routes.ts:
Issue:

The backend might unintentionally block gallery access if auth checks aren't bypassed for public routes.
Solution:

In routes.ts, ensure that public routes allow viewing without requiring authentication:
ts
Copy code
app.get('/api/galleries/:slug', async (req, res) => {
  try {
    const gallery = await db.query.galleries.findFirst({
      where: eq(galleries.slug, req.params.slug),
    });

    if (!gallery) {
      return res.status(404).json({ message: 'Gallery not found' });
    }

    // Return gallery details without enforcing authentication
    res.json({
      id: gallery.id,
      title: gallery.title,
      slug: gallery.slug,
      userId: gallery.userId,
      images: gallery.images
    });
  } catch (error) {
    console.error('Error fetching gallery:', error);
    res.status(500).json({ message: 'Failed to fetch gallery' });
  }
});
