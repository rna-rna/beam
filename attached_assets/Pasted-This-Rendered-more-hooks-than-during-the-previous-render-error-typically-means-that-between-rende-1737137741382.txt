This “Rendered more hooks than during the previous render” error typically means that, between renders, React sees a different sequence (or count) of hooks being called—something React’s hook rules don’t allow. In a loop like folders.map(...), you can safely call a hook (like useDrop) once per folder in a stable order, as long as:

You always call the hook exactly once for each folder in the map (no conditional hook calls inside the map).
The order of the folders array is stable (you don’t shuffle or reorder it without using keys properly).
Below are the most common causes and fixes:

1. Conditional Hook Calls in the Loop
If your code is doing something like:

tsx
Copy
folders.map((folder) => {
  if (folder.isSomething) {
    // call useDrop
    const [{ isOver }, dropRef] = useDrop(...);
  }
  return ( ... );
})
Then any time folder.isSomething toggles from false to true, you go from “no hook” to “one hook,” which changes the total hook count. Fix by always calling useDrop unconditionally:

tsx
Copy
folders.map((folder) => {
  // ALWAYS call useDrop, but if you want to skip logic, do it inside dropSpec
  const [{ isOver }, dropRef] = useDrop(() => dropSpec(folder), [folder.id]);

  return (...);
});
(Where dropSpec is an object or function you define that might do nothing if folder.isSomething is false, but you still call the hook every time.)

2. Reordering the Folders Without Stable Keys
If you do something like folders.sort(...) on every render (especially without stable keys), React might see the items swap positions from render to render, thus the “nth item” calls a different set of hooks next time.

Make sure you apply sorting once or apply a stable sort that doesn’t shuffle items.
Also ensure each folder has a stable key={folder.id} so React can track them across re-renders.
3. Different Array Length / Early Returns in the Map
Sometimes you might do:

tsx
Copy
return folders.map((folder) => {
  if (folder.deleted) {
    return null; // skip calling useDrop
  }
  // call useDrop
});
If folder.deleted changes mid-lifecycle, now you’ve changed how many times you call useDrop. Instead, always call the hook, then conditionally render null inside the returned JSX. Example:

tsx
Copy
return folders.map((folder) => {
  const [{ isOver }, dropRef] = useDrop(...);

  if (folder.deleted) {
    // still call the hook, but just render null
    return null;
  }

  return (...);
});
Summary of the Fix
Call useDrop once per item in the map—unconditionally.
Ensure stable ordering of folders.map(...). If you must reorder them, provide a stable key.
Never conditionally skip the hook call or place it inside an if/else; if you need conditional logic, do it inside the dropSpec, but still call useDrop in the same place for each folder.