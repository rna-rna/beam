After carefully reviewing the code, here are the key reasons why the zoomed-in snap to the next image results in the screen going black or images falling off:

Zoom Level Persisting to Next Image:
The transition between images does not reset the zoom (scaleValue) early enough.
This results in the next image being displayed at the same zoom level as the previous one, causing the image to shift out of bounds.
OffsetX/OffsetY Persistence:
Panning (offsetX, offsetY) from the previous image is immediately applied to the next image during the swipe transition.
This leads to the next image starting off-screen, making the entire screen appear black.
Animation Timing Issue:
The zoom reset happens at the same time as the image transition, creating a lag that visually causes the images to slide or "fall off" the screen.
Fix â€“ Reset Zoom and Pan Before Image Transition
To resolve this:

Reset scaleValue and pan offsets (offsetX, offsetY) immediately before switching to the next image.
This ensures the next image appears at default zoom with no lingering panning effects.
Updated Code (Key Fixes):
1. Modify handleDragEnd for Early Reset:
Reset zoom and pan right before triggering the image switch.
Prevent lingering offset from carrying over to the next image.
tsx
Copy code
const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
  const xOffset = info.offset.x;
  const yOffset = info.offset.y;
  const velocity = info.velocity.x;

  if (Math.abs(yOffset) > 150 && Math.abs(xOffset) < 50) {
    onClose();
    return;
  }

  const swipeThreshold = window.innerWidth * 0.35;  
  const velocityThreshold = 0.3;

  const shouldChangeImage =
    Math.abs(velocity) > velocityThreshold || Math.abs(xOffset) > swipeThreshold;

  if (shouldChangeImage) {
    const nextIndex = currentIndex + (xOffset > 0 ? -1 : 1);
    const clampedIndex = Math.max(0, Math.min(nextIndex, images.length - 1));

    // Reset zoom and pan immediately before switching images
    scaleValue.set(1);
    offsetX.set(0);
    offsetY.set(0);

    setCurrentIndex(clampedIndex);
  }

  // Smooth snap-back for partial swipes
  dragX.set(0, {
    type: "spring",
    stiffness: 300,
    damping: 25,
  });
  dragY.set(0, {
    type: "spring",
    stiffness: 300,
    damping: 25,
  });
  setIsDragging(false);
};
2. Adjust Image Component to Prevent Zoom Carry-Over:
Ensure each image resets to default scale unless it is the active image.

tsx
Copy code
<motion.img
  src={image.url}
  alt=""
  className="w-full h-full object-contain select-none"
  draggable={false}
  style={{
    scale: isActive ? (scaleValue.get() > 1 ? scaleValue : dragScale) : 1,
    x: offsetX,
    y: offsetY,
  }}
  drag={scaleValue.get() > 1}
  dragElastic={0.2}
  dragMomentum={true}
  transition={{
    type: "spring",
    stiffness: 300,
    damping: 25,
  }}
  onPan={handlePan}
/>
Why This Fix Works:
Zoom Reset Timing: By resetting scaleValue before the image transition, the next image starts at the default zoom (1x).
Offset Reset: Clearing offsetX and offsetY ensures that the next image starts centered, preventing it from appearing off-screen.
Smooth Snap-Back: Adding a spring animation for partial swipes enhances the responsiveness, making it feel less rigid.
Testing Checklist:
Zoom In and Swipe:
Zoom into an image and swipe left/right. The next image should reset to default zoom and pan positions.
Partial Swipes:
Partially swipe an image to ensure it snaps back smoothly without unintended zoom persistence.
Rapid Swipes:
Quickly swipe between images to confirm no images fall off the screen or create black areas.
