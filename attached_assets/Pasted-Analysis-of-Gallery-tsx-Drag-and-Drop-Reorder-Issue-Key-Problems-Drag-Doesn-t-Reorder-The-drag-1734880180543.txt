Analysis of Gallery.tsx (Drag-and-Drop Reorder Issue):
Key Problems:
Drag Doesn’t Reorder:

The drag event (onDragEnd) visually moves images, but the underlying reorder logic doesn't finalize the new position.
The handleDragEnd attempts to reorder by measuring proximity to other images, which may not trigger accurately in a grid layout.
Framer Motion Animation Degradation:

The whileDrag and exit animations introduce stretching and fading effects, which may lead to visual inconsistencies.
Proposed Fixes:
1. Fix Drag-and-Drop Reorder Logic (Accurate Placement Across Grid):
The current logic calculates distance, but this can result in misplaced or ignored drops.
Instead, track the dragged image’s position relative to the mouse and dynamically adjust grid placement.

Key Changes:
Calculate new order by comparing the dragged item’s center to the center of the nearest item.
Shift the entire array based on real-time cursor position during drag.
tsx
Copy code
const handleDragEnd = useCallback((
  event: PointerEvent | MouseEvent | TouchEvent,
  draggedIndex: number,
  info: PanInfo
) => {
  if (!gallery || !isReorderMode) return;

  const galleryItems = Array.from(document.querySelectorAll(".image-container"));

  if (galleryItems.length === 0 || draggedIndex >= galleryItems.length) return;

  let targetIndex = draggedIndex;
  let closestDistance = Infinity;

  // Get cursor position at drag end
  const cursorPos = {
    x: event instanceof MouseEvent ? event.clientX : (event as TouchEvent).touches[0].clientX,
    y: event instanceof MouseEvent ? event.clientY : (event as TouchEvent).touches[0].clientY,
  };

  galleryItems.forEach((item, index) => {
    if (index === draggedIndex) return;

    const rect = item.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Calculate Euclidean distance
    const distance = Math.hypot(centerX - cursorPos.x, centerY - cursorPos.y);

    if (distance < closestDistance) {
      closestDistance = distance;
      targetIndex = index;
    }
  });

  // Reorder images if targetIndex changes
  if (targetIndex !== draggedIndex) {
    const updatedImages = [...gallery.images];
    const [movedImage] = updatedImages.splice(draggedIndex, 1);
    updatedImages.splice(targetIndex, 0, movedImage);

    // Optimistic Update (Immediate Visual Feedback)
    queryClient.setQueryData([`/api/galleries/${slug}`], {
      ...gallery,
      images: updatedImages,
    });

    // Send update to backend
    reorderImageMutation.mutate(updatedImages.map((img) => img.id));
  }
}, [gallery, isReorderMode, queryClient, reorderImageMutation, slug]);
2. Restore Framer Motion Animations (Avoid Stretching and Fading):
Stretching occurs due to scale and box shadow applied during drag (whileDrag).
Fading issues arise from the exit prop, which causes opacity transitions that shouldn’t trigger on simple drag-and-drop.
Update renderImage to Restore Smooth Animations:
tsx
Copy code
<motion.div
  key={image.id}
  className={`mb-4 image-container relative ${!isMasonry ? 'aspect-[4/3]' : ''}`}
  initial={{ opacity: 0, y: 20 }}
  animate={{ opacity: 1, y: 0 }}
  exit={{ opacity: 0 }}  // Only fade on actual exit, not drag
  transition={{ duration: 0.3 }}
  drag={isReorderMode}
  dragElastic={0.15}
  dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}  // Prevent excessive stretching
  onDragEnd={(event, info) => handleDragEnd(event as PointerEvent, index, info)}
  whileDrag={{
    scale: 1.03,  // Less aggressive scale
    zIndex: 100,
    boxShadow: "0 10px 15px rgba(0,0,0,0.1)",  // Subtle drag feedback
  }}
  layout
>
3. Add Dynamic Placeholders (Highlight Drop Targets):
To improve UX, introduce dynamic placeholders that shift as the image is dragged. This gives visual feedback showing where the item will land.

Implementation:
Use motion.div with layout transitions to push other images slightly apart when dragging.
tsx
Copy code
{gallery?.images.map((image: Image, index: number) => (
  <motion.div
    key={image.id}
    layout
    animate={{
      scale: isReorderMode ? 0.97 : 1,
    }}
    whileDrag={{
      scale: 1.05,
    }}
    className="relative image-container"
  >
    <img
      src={image.url}
      alt=""
      className="w-full h-auto object-cover rounded-lg"
    />
  </motion.div>
))}
4. Persistent Reorder Mode (Until Manually Exited):
Ensure reorder mode stays active until explicitly exited by the user.

tsx
Copy code
const toggleReorderMode = () => {
  setIsReorderMode(!isReorderMode);
};
