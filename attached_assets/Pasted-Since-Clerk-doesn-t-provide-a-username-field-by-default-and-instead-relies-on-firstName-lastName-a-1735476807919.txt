Since Clerk doesn’t provide a username field by default and instead relies on firstName, lastName, and imageUrl, the issue likely stems from incorrect assumptions about how user data is structured.

Root Cause of the Problem:
Backend and Frontend Misalignment:

The frontend expects an author or username field that doesn't exist in Clerk’s user object.
Clerk's user object uses firstName, lastName, and imageUrl, but these aren't mapped correctly in comments.
Fallback to "Unknown User":

When author.username is referenced and doesn’t exist, the fallback logic assigns "Unknown User".
This fallback is unnecessary if firstName and lastName are correctly handled.
How to Fix It:
1. Adjust the Frontend to Use Clerk’s User Fields Directly:
1.1 Update CommentBubble.tsx to Use firstName and lastName:

Replace references to author.username with user.firstName and user.lastName.
tsx
Copy code
const authorDisplay = typeof author === 'string'
  ? { username: author, imageUrl: undefined }
  : {
      username: `${author?.firstName || 'Unknown'} ${author?.lastName || 'User'}`.trim(),
      imageUrl: author?.imageUrl
    };
Why:
This directly maps to the user object Clerk provides.
Even if firstName or lastName is missing, it falls back gracefully without using username at all.
1.2 Update Optimistic Comment in CommentBubble.tsx:

When submitting a new comment, use firstName and lastName directly:
tsx
Copy code
const optimisticComment = {
  id: Date.now(),
  content: newCommentText,
  xPosition: x,
  yPosition: y,
  user: {
    id: user.id,
    firstName: user.firstName,
    lastName: user.lastName,
    imageUrl: user.imageUrl
  },
  optimistic: true
};
Why:
This ensures new comments display with the correct user information immediately without relying on author or username.
1.3 Modify Comment Rendering to Reflect user Object Correctly:

Update how the comment is rendered to avoid username:
tsx
Copy code
<UserAvatar
  name={`${authorDisplay.username}`}
  imageUrl={authorDisplay.imageUrl}
  className="w-6 h-6 text-xs"
/>
<p className="text-xs font-medium text-muted-foreground">
  {authorDisplay.username}
</p>
Why:
This pulls firstName and lastName directly and avoids unnecessary fallbacks.
2. Adjust the Comment Fetching Logic in Gallery.tsx:
2.1 Update the Comment Mapping to Use Clerk’s user Structure:

tsx
Copy code
select: (data) => {
  return data.map((comment) => ({
    ...comment,
    author: comment.user
      ? {
          username: `${comment.user.firstName || ''} ${comment.user.lastName || ''}`.trim(),
          imageUrl: comment.user.imageUrl
        }
      : {
          username: "Unknown User",
          imageUrl: undefined
        }
  }));
};
Why This Fix Works:
This prevents the fallback to username and directly maps the user object from Clerk.
3. Backend Adjustment (Optional, But Recommended):
If the backend sends author instead of user, modify it to return user directly:
javascript
Copy code
const comments = await db.query.comments.findMany({
  where: { imageId: req.params.id },
  include: {
    user: {
      select: {
        firstName: true,
        lastName: true,
        imageUrl: true
      }
    }
  }
});
Why:
This ensures consistency across the frontend and backend, preventing mismatches in field names.
