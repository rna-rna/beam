

Thought for 4 seconds
Below is a step-by-step outline of how to keep unread vs. read notifications visible, let the user see which ones are unread, and allow them to explicitly mark them all as read.

1. Add/Confirm a Read Flag in Your DB
In your notifications table, you likely already have isSeen: boolean. Ensure it defaults to false for new notifications.
If you’re storing notifications in some other structure, make sure you have a boolean property to indicate if it’s read or not.
Example DB schema snippet (conceptual):

sql
Copy
Edit
ALTER TABLE notifications
  ADD COLUMN IF NOT EXISTS isSeen BOOLEAN NOT NULL DEFAULT FALSE;
2. Server Endpoint: “Mark All as Read”
You probably already have an endpoint like:

ts
Copy
Edit
protectedRouter.post('/api/notifications/mark-all-read', async (req, res) => {
  try {
    const userId = req.auth.userId;
    await db.update(notifications)
      .set({ isSeen: true })
      .where(eq(notifications.userId, userId));

    return res.json({ success: true });
  } catch (error) {
    console.error('Error marking notifications read:', error);
    return res.status(500).json({ success: false, message: 'Server error' });
  }
});
This sets all notifications for the user to isSeen = true.

3. Keep Notifications in Client State, Including isSeen
In your React code (e.g., NotificationSystem.tsx), you might already do:

ts
Copy
Edit
// ...
export interface Notification {
  id: string;
  type: string;
  isSeen: boolean;
  // ...
}

// ...
const [notifications, setNotifications] = useState<Notification[]>([]);
When you fetch from /api/notifications, make sure the JSON includes the isSeen flag so you can store it in notifications state. For example:

ts
Copy
Edit
const fetchNotifications = async () => {
  try {
    const res = await fetch("/api/notifications", { credentials: "include" });
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    const data = await res.json();
    
    // Suppose your server returns { success: true, data: [ { isSeen, ... } ] }
    if (data.success && Array.isArray(data.data)) {
      setNotifications(data.data);
    }
  } catch (error) {
    console.error("Error fetching notifications:", error);
  }
};
4. Use the isSeen Flag to Style Unread Notifications
Within your dropdown list (e.g., NotificationDropdown component), you can do something like:

tsx
Copy
Edit
{notifications.map((notification) => {
  const isUnread = !notification.isSeen;
  return (
    <div
      key={notification.id}
      // If it’s unread, highlight with a background color
      className={`p-4 border-b ${
        isUnread ? "bg-accent/20" : "bg-transparent"
      }`}
    >
      {/* Notification content */}
      ...
    </div>
  );
})}
Or you can apply a bold style or special border.
The key idea is: if notification.isSeen === false, visually emphasize.
5. Add a “Mark All as Read” Button
Inside your bell dropdown or inside NotificationSystem, add a button:

tsx
Copy
Edit
function NotificationDropdown({ notifications, onClose }) {
  const markAllAsRead = async () => {
    try {
      const res = await fetch("/api/notifications/mark-all-read", {
        method: "POST",
        credentials: "include",
      });
      if (res.ok) {
        // Locally update our notifications array
        setNotifications(prev =>
          prev.map(n => ({ ...n, isSeen: true }))
        );
      }
    } catch (error) {
      console.error("Failed to mark all as read:", error);
    }
  };

  return (
    <div>
      <div className="flex justify-between p-2">
        <span className="font-semibold">Notifications</span>
        <button
          onClick={markAllAsRead}
          className="text-sm text-blue-500 hover:underline"
        >
          Mark All as Read
        </button>
      </div>
      {/* ... show notifications below ... */}
    </div>
  );
}
This calls the same backend endpoint that sets isSeen = true. Then it also updates your local state so the UI reflects that everything is now read (no more highlight).

6. Badge Count
To show how many are unread in the bell icon:

ts
Copy
Edit
// e.g. NotificationBell.tsx
const unseenCount = notifications.filter(n => !n.isSeen).length;
return (
  <Button>
    <BellIcon />
    {unseenCount > 0 && <span>{unseenCount}</span>}
  </Button>
);
Once you click “Mark All as Read,” the local notifications array is updated (all isSeen = true), so unseenCount becomes 0. The bell badge disappears, but the notifications remain in the dropdown (now styled as read).