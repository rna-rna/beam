2. Create a Notification Service
Make a new file, for example: services/notificationService.ts. This service centralizes all logic for creating or updating notifications. It ensures that if a new event arrives within 5 minutes of a prior event (same user, gallery, type, etc.), we update an existing row rather than creating a new one.

ts
Copy
Edit
// services/notificationService.ts

import { db } from '@db';
import { notifications } from '@db/schema'; // or wherever your schema is
import { eq, and, gte, sql } from 'drizzle-orm';
import { pusher } from '../pusherConfig';  // adjust path as needed
import { nanoid } from 'nanoid';

const GROUPING_WINDOW_MINUTES = 5;

interface CreateOrUpdateNotificationOptions {
  recipientId: string;   // user who will RECEIVE the notification
  actorId: string;       // user who CAUSED the event (e.g. starred)
  galleryId: number;     // which gallery the event is about
  type: string;          // e.g. 'image-starred', 'comment-added', 'reply'
  data?: any;            // extra JSON payload, e.g. { imageId, excerpt, ... }
}

export async function createOrUpdateNotification({
  recipientId,
  actorId,
  galleryId,
  type,
  data = {},
}: CreateOrUpdateNotificationOptions) {

  // 1. Check if there's a recent notification (within grouping window)
  const fiveMinAgo = sql`NOW() - INTERVAL '${GROUPING_WINDOW_MINUTES} minutes'`;
  const existing = await db.query.notifications.findFirst({
    where: and(
      eq(notifications.userId, recipientId),
      eq(notifications.type, type),
      eq(notifications.actorId, actorId),
      eq(notifications.galleryId, galleryId),
      gte(notifications.createdAt, fiveMinAgo) // createdAt >= 5 min ago
    ),
    orderBy: (table, { desc }) => [desc(table.createdAt)],
  });

  if (existing) {
    // 2. If found, increment count and update 'createdAt'
    const newCount = (existing.count || 1) + 1;
    await db.update(notifications)
      .set({
        count: newCount,
        createdAt: new Date(), // so it's "fresh" for sorting
        needsEmail: true,      // still needs an email
        data: data,            // optional: you can also merge data if you want
      })
      .where(eq(notifications.id, existing.id));

    // 3. Trigger Pusher with the updated count
    pusher.trigger(`presence-gallery-${galleryId}`, type, {
      notificationId: existing.id,
      updatedCount: newCount,
      actorId,
      data,
    });
  } else {
    // 4. Otherwise, create a new notification
    const groupId = nanoid();
    const [newNotification] = await db.insert(notifications).values({
      userId: recipientId,
      actorId,
      galleryId,
      type,
      data,
      groupId,
      count: 1,
      isSeen: false,
      createdAt: new Date(),
      // groupedUntil: new Date( Date.now() + GROUPING_WINDOW_MINUTES * 60000 ), // optional
      needsEmail: true,
    }).returning();

    // 5. Trigger Pusher with the new record
    pusher.trigger(`presence-gallery-${galleryId}`, type, {
      notificationId: newNotification.id,
      updatedCount: 1,
      actorId,
      data,
    });
  }
}
Notes:

presence-gallery-${galleryId}: If you prefer, you can keep using presence-gallery-${gallery.slug}. Just pass the slug or ID. The important part is that all relevant watchers (owners, editors) are subscribed.
recipientId: This is who receives the notification. For owners & editors, you’ll loop over them. For a comment reply, it’s the parent commenter.
